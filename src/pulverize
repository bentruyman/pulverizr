#!/usr/bin/env node

/*
 * Pulverizr
 * 
 * Copyright (c) 2010, Benjamin Truyman.
 * All rights reserved.
 *
 * Licensed under the BSD license.
 */

require.paths.unshift('../lib/node-promise');
require.paths.unshift('/usr/local/lib/node-promise');

var exec = require('child_process').exec,
	fs = require('fs'),
	path = require('path'),
	promise = require('promise');
	sys = require('sys');

var Promise = promise.Promise,
	all = promise.all,
	when = promise.when;

// Define constants
var fileTypes = {
		GIF: 'GIF',
		JPEG: 'JPEG',
		PNG: 'PNG'
	},
	extensions = {
		gif: fileTypes.GIF,
		jpg: fileTypes.JPEG,
		jpeg: fileTypes.JPEG,
		png: fileTypes.PNG
	},
	TMP = process.cwd(),
	VERSION = 'BETA';

// Options to use throughout the program
var options = {
	dry: false,
	fileTypes: {},
	input: [],
	loud: true,
	recursive: false,
	verbose: false
};

// Variables to be help until the end report is printed
var report = {
	fileCount: 0,
	scanned: {},
	size: {
		start: 0,
		end: 0
	},
	time: {
		start: Date.parse(new Date()),
		end: null
	}
};

// Parse the arguments into consumable bits (flags, key/value pairs)
// TODO: Add ability to set values to parameters passed (e.g. --foo=bar or -f bar) if it's even necessary
var args = [];
process.argv.slice(2).forEach(function (arg, index) {
	if (arg.match(/^\-[a-zA-Z]$/)) { // If it's a shorthand flag
		push(arg, true);
	} else if (arg.match(/^\-[a-zA-Z]+$/)) { // If it's a combined shorthand flag
		for (var i = 1; i < arg.length; i++) {
			push('-' + arg.charAt(i), true);
		}
	} else if (arg.match(/^\-\-[a-zA-Z\-]+$/)) { // If it's a longhand flag
		push(arg, true);
	} else { // Assume it's a file since it didn't match any of our flags
		options.input.push(arg);
	}

	function push (name, value) {
		args.push({
			name: name,
			value: value
		});
	}
});

// Response functions
var responses = {
	error: function (message) {
		sys.puts('Error occurred: ' + message);
	},
	help: function () {
		sys.puts('Usage: pulverize [OPTION]... [FILE]...');
		sys.puts('Smash your images down to size. Pulverizr uses several compressors/optimizers');
		sys.puts('to squeeze every last bit out of your images. If Pulverizr detects an');
		sys.puts('optimization, it overwrites the old image with the newly optimized one.');
		sys.puts('');
		sys.puts('Options:');
		sys.puts('');
		sys.puts(' General:');
		sys.puts('  -a, --aggressive	uses more aggressive compression algorithms (takes longer, \n\t\t\tworks better)');
		sys.puts('  --dry-run		print summary but don\'t actually modify files');
		sys.puts('  -q, --quiet		pulverizer will stfu');
		sys.puts('  --verbose		verbose mode');
		sys.puts('');
		sys.puts(' Traversing:');
		sys.puts('  -R, --recursive	scan directories recursively');
		// sys.puts('  -g, --gif		whitelist gif images');
		// sys.puts('  -j, --jpeg		whitelist jpeg images');
		// sys.puts('  -p, --png		whitelist png images');
		sys.puts('');
		sys.puts(' Other:');
		sys.puts('  -h, --help		print this handy dandy help page');
		sys.puts('  -v, --version		print program version');
	},
	report: function () {
		var diff = {
			perc: Math.round((100 * ((report.size.start / report.size.end) - 1)) * 100) / 100,
			size: Math.round(((report.size.start - report.size.end) / 1024) * 100) / 100
		};

		var timeSpent = Math.round(((report.time.end - report.time.start) / 1000) * 10) / 10;

		if (options.loud) {
			sys.puts('===============================================================================');
			sys.puts('Report:');
			sys.puts('  - File Affected: ' + report.fileCount);
			sys.puts('  - Old Size: ' + report.size.start + ' bytes');
			sys.puts('  - New Size: ' + report.size.end + ' bytes');
			sys.puts('  - Savings: ' + diff.size + 'KB (' + diff.perc + '%)');
			sys.puts('  - Time Spent: ' + timeSpent + ' seconds');

			if (options.dry) {
				sys.puts('\nThis was a dry run. No files were actually modified.');
			}

			sys.puts('');
		}
	},
	version: function () {
		sys.puts('Pulverize v' + VERSION);
	}
};

var tasks = {};

tasks[fileTypes['GIF']] = function (filename, promise) {
	exec('gifsicle -O -b ' + filename, function (error, stdout, stderror) {
		if (error) {
			if (error.code === 127 && options.loud) {
				sys.puts('Could not find "gifsicle". Skipping on: ' + filename);
			}
		}
		promise.resolve(fs.statSync(filename));
	});

	return promise;
};

tasks[fileTypes['JPEG']] = function (filename, promise) {
	// jpegtran won't let us overwrite the file
	var jpegtranTmp = generateFilename();

	exec('jpegtran -optimize -outfile ' + jpegtranTmp + ' ' + filename, function (error, stdout, stderror) {
		if (error) {
			if (error.code === 127 && options.loud) {
				sys.puts('Could not find "jpegtran". Skipping on: ' + filename);
			}
		} else {
			fs.renameSync(jpegtranTmp, filename);
		}
		promise.resolve(fs.statSync(filename));
	});

	return promise;
};

tasks[fileTypes['PNG']] = function (filename, promise) {
	// pngcrush won't let us overwrite the file
	var pngcrushTmp = generateFilename(),
		optipngLevel = 'o1';

	if (options.aggressive) {
		optipngLevel = 'o7';
	} 

	exec('optipng -' + optipngLevel + ' ' + filename, function (error, stdout, stderror) {
		if (error) {
			if (error.code === 127 && options.loud) {
				sys.puts('Could not find "optipng". Skipping on: ' + filename);
			}
		}
		exec('pngcrush -nofilecheck -q ' + filename + ' ' + pngcrushTmp, function (error, stdout, stderror) {
			if (error) {
				if (error.code === 127 && options.loud) {
					sys.puts('Could not find "pngcrush". Skipping on: ' + filename);
				}
			} else {
				fs.renameSync(pngcrushTmp, filename);
			}
			promise.resolve(fs.statSync(filename));
		});
	});

	return promise;
};

if (options.input.length === 0) {
	respond('help');
} else {
	args.forEach(function (arg) {
		switch (arg.name) {
			// General
			case '-a': options.aggressive = true; break;
			case '--aggressive': options.aggressive = true; break;
			case '--dry-run': options.dry = true; break;
			case '-q': options.loud = false; break;
			case '--quiet': options.loud = false; break;
			case '--verbose': options.verbose = true; break;
			// Traversing
			case '-R': options.recursive = true; break;
			case '--recursive': options.recursive = true; break;
			case '-g': options.fileTypes[fileTypes.GIF] = true; break;
			case '--gif': options.fileTypes[fileTypes.GIF] = true; break;
			case '-j': options.fileTypes[fileTypes.JPEG] = true; break;
			case '--jpeg': options.fileTypes[fileTypes.JPEG] = true; break;
			case '-p': options.fileTypes[fileTypes.PNG] = true; break;
			case '--png': options.fileTypes[fileTypes.PNG] = true; break;
			// Other
			case '-h': respond('help'); break;
			case '--help': respond('help'); break;
			case '-v': respond('version'); break;
			case '--version': respond('version'); break;
		}
	});

	// Begin compression routine
	if (options.loud) {
		sys.puts('Get ready to be Pulverized!');
		sys.puts('===============================================================================');
	}

	var promises = [];

	function scan (filename, depth) {
		var stats = fs.statSync(filename);
		if (stats.isFile()) {
			var promise = compress(filename);
			if (promise !== null) {
				promises.push(promise);
			}
			report.scanned[filename] = true;
		} else if ((options.recursive || depth == 0) && !report.scanned[filename] && stats.isDirectory()) {
			depth++;
			fs.readdirSync(filename).forEach(function (_filename) {
				// Scans the directory, and strips off a trailing slash if it exists
				scan(filename.replace(/(\/)$/g, '') + '/' + _filename, depth);
			});
		}
	}

	options.input.forEach(function (filename) {
		scan(filename, 0);
	});

	all(promises).then(function () {
		report.time.end = Date.parse(new Date());
		respond('report');
	});
}

function compress (filename) {
	// Try to find a task for the current file. If nothing is found, no task is executed
	var task = tasks[fileTypes[extensions[path.extname(filename).substr(1)]]];

	if (task) {
		var promise = new Promise(),
			tmp = generateFilename();

		// Copy the old file to a temporary spot
		exec('cp ' + filename + ' ' + tmp, function (error, stdout, stderr) {
			task.call(this, tmp, promise).then(function (newStats) {
				var oldStats = fs.statSync(filename);

				if (options.verbose) {
					if (newStats.size < oldStats.size) {
						sys.puts('Compressed ' + filename + ' from ' + oldStats.size + ' bytes down to ' + newStats.size + ' bytes');
					} else {
						sys.puts(filename + ' could not be compressed any more');
					}
				}

				// Update the report
				report.size.start += oldStats.size;
				report.size.end += newStats.size;
				report.fileCount++;

				// If optimizations were made and this isn't a dry run, copy the new file over
				if (!options.dry && newStats.size < oldStats.size) {
					fs.renameSync(tmp, filename);
				} else {
					// Remove the temporary file
					fs.unlinkSync(tmp);
				}
			});
		});

		return promise;
	}
}

function generateFilename () {
	// Generate a random string
	var filename = TMP + '/' + Math.floor(Math.random() * 1e16).toString(36);

	try {
		fs.statSync(filename);
	} catch (e) {
		// It's good if we get an error, it means the random filename we created doesn't already exist
		return filename;
	}

	// Otherwise we need to try again (what are the chances of that??)
	return generateFilename();

}

function respond (name) {
	// TODO: Overloading global args var. This is okay, right?
	var args = [];

	for (var i = 1; i < arguments.length; i++) {
		args.push(arguments[i]);
	}

	responses[name].apply(this, args);
	process.exit();
}

function inspect (obj) {
	sys.puts(sys.inspect(obj));
}
